---
layout: post
title: Image Effects - Part 2 - Blurring Algorithms
subtitle: Blurring the lines and considering multiple pixels simultaneously
bigimg: /img/tut1/part2-banner.png
tags: [shaders, unity]
nice-slug: Blurring Algorithms
date: 2019-04-12 02:00:00
---

There are several kinds of blurring algorithm, some more efficient than others. Super Mario Odyssey blurs the image from the corners inwards, so that the focal point of the camera remains sharp. This tutorial introduces some blurring algorithms, which involve considering multiple pixels at the same time.

![Blur](/img/tut1/part2-blur.png)

# Box Blur

Let's introduce the idea of a kernel function. Imagine a square matrix of numbers with odd dimentions - so 1x1, 3x3, 5x5 and so on; this is called a kernel. When we 'apply' a kernel to an image (the technical term is "convolution"), we place that kernel pixel-wise over the image, so that each matrix value lies over an individual pixel. Then, we multiply each kernel value by the colour inside the corresponding pixel. Those values are added together, and we divide the total by the sum of the numbers inside the original kernel matrix; this total is a kind of weighted average, which becomes the output value for the central pixel that we just operated on. For the sake of simplicity, since we're working with RGB colour data, we calculate the red, green and blue colour channels individually during the convolution process.

For a box blur, we do the process detailed above with a kernel full of ones. In other words, it's an unweighted average. For each pixel of the image, the output colour is the equally-weighted average of the NxN pixels surrounding it - the amount of blurring in the image is influenced only by the value of N. You can imagine where the name "box blur" comes from!

# Gaussian Blur

A box blur does the job of blurring the image, but there are other blurring algorithms that give finer results. A slightly more complicated algorithm is the Gaussian blur algorithm. It's similar to a box blur in that it entails convolving another square matrix with an image, but this time we'll calculate kernel values such that the central pixel is more highly weighted than the surrounding pixels.

The stats buffs in the crowd will recognise a Gaussian distribution from the after-images when they close their eyes at night - the normalised Gaussian curve is symmetric, with a mean, \\( \mu\\), of zero. It's also known as the Normal distribution.

\\[ 
    G(x) = \frac{1}{\sigma \sqrt{2\pi}} e ^ {-\frac{(x-\mu)^2}{2 \sigma^2}}
\\]
\\[
    where \space \mu = 0
\\]

The relevant property of the function for us is that we can tweak how tall and wide the distribution is by modifying a single parameter - the standard deviation, \\( \sigma \\). Now imagine a 3D Gaussian curve - place it over the image with the peak of the curve over the top of some pixel. We're going to sum over the pixels around that central one, using the height of the curve at each pixel position as a weight. Does that remind you somewhat of how we placed the kernel function over an image for box blur?

We can implement a Gaussian blur by populating a kernel with the height values of a 3D Gaussian function, where, conceptually, the curve protrudes from the screen with the z-axis in the centre. We must take into account another property of the Gaussian curve: it never touches the x- or y-axes, so the 'tails' of the function extend infinitely. Since it's infeasible to run the convolution step using the entire image for every single pixel, we'll provide some bounding window to cut off those tails and only use part of the Gaussian curve. Luckily, we can just use an NxN kernel, as before. In this way, the amount of blurring is controlled by two parameters this time - N and \\( \sigma \\). Remember the final step of dividing by the sum of the kernel values, otherwise the image will become darker - the values will sum to slightly less than 1.

There's a nice optimisation to implement here, too. Another nice property of a Gaussian function is that it is linearly separable - running a Gaussian function like this in the x- and z-axes simultaneously is exactly the same as running the function in the x-direction and then again in the y-direction. This cuts out a lot of computation, but we need to run two shader passes.

# Pulling It Together

# Conclusion

You now have a little more shader know-how under your belt - you can use multiple pixel values simultaneously, and you know more about the theoretical basis of kernel functions. Next time, we'll recreate the Silhouette effect in Super Mario Odyssey and use some of the built-in features of the graphics pipeline to assist us.
