---
layout: post
title: Cel Shading | Part 3 - Bump Mapping and Fresnel Lighting
subtitle: Extra lighting details and lighting the edges
bigimg: /img/tut2/part3-banner.png
gh-repo: daniel-ilett/cel-shading
gh-badge: [star, fork, follow]
tags: [shaders, unity, lighting, cel-shading, fresnel]
nice-slug: Fresnel Lighting
date: 2019-06-05
---

Today we'll build on the effect we've built so far and add more detail to our lighting calculations using so-called 'bump mapping'. Then, we'll add a subtle lighting effect on the edges of objects called fresnel lighting.

For this tutorial, I'll only be using surface shaders, but it should be relatively simple to implement a vertex and fragment shader variant using the information contained in this tutorial article.

<hr/>

# Bump Mapping

<hr/>

# Fresnel Lighting

Fresnel lighting (pronounced "fre-nel", with a silent 's') arises when the viewer is looking at an object at a very shallow angle. When looking at a steep angle, the lighting will be as normal - but at shallower angles, a much higher proportion of the light is reflected off the surface; this is especially true of transparent materials, which tend to reflect a higher proportion of light at shallow viewing angles than they transmit through their surfaces. That's why you might not be able to see what's underwater if you're looking at a pool of water at a shallow angle, when the floor is perfectly visible when looking from above.

For us, it'll let us light the edges of objects as they curve away from us - imagine a ball; we'll light the 'edges' of the ball within our vision. It's also known as 'rim lighting' in computer graphics becasue we commonly use it to light the rim of objects.

As established, the fresnel lighting depends on the normal vector of the object and the view vector of the camera to the object - the lighting direction doesn't matter. We'll use the one trick we have up our sleeve when it comes to lighting - the dot product - to determine to what degree the viewing vector and normal vector match up, then subtract the result from 1 to invert it because we want to light areas where the normal faces perpendicular to the viewing  direction. Take a look at `Shaders/RimCelShader.shader` and add this line after the `specularSmooth` calculation in the `LightingCel` function.

~~~glsl
float rim = 1 - dot(normal, viewDir);
~~~

This is the basic fresnel calculation, complete. But we've been stylising our lighting calculations so far, so we'll modify it to fit with the cel-shaded style we've developed so far. Before we perform a two-tone cut and smooth (and before we sound too much like a hairdresser), we'll multiply the `rim` value by the existing basic diffuse lighting value - we don't want to light objects that aren't actually hit by the directional light.

~~~glsl
// Don't apply rim lighting in shaded areas.
rim = rim * diffuse;
~~~

We'll also introduce a property to control where we make our cut. It'll be nice to have control over how big the fresnel effect is; some values look better on some objects.

~~~glsl
// In Properties.
_Fresnel("Fresnel/Rim Amount", Range(0, 1)) = 0.5

// With variable declarations.
float _Fresnel;

// Calculate fresnel value in LightingCel.
float fresnelSize = 1 - _Fresnel;
~~~

Finally, we'll apply our cutting and smoothing step. We'll use `smoothstep` with the `fresnelSize` we just calculated.

~~~glsl
float rimSmooth = smoothstep(fresnelSize, fresnelSize * 1.1, rim);

// Add rim lighting to final colour calculation.
float3 col = s.Albedo * ((diffuseSmooth + specularSmooth + rimSmooth) * _LightColor0 + unity_AmbientSky);
~~~

Boy our lighting calculation is getting big! Luckily for us, we're done here. Let's take a look at Ethan now.

![Fresnel Ethan](/img/tut2/part3-ethan-bump-fresnel.png){: .center-image }

He still looks like a gummy bear, but now he's an *even higher* quality gummy bear.

<hr/>

# Conclusion

<hr/>
