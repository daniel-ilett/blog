---
layout: post
title: Cel Shading | Part 1 - Diffuse Lighting
subtitle: Defining the properties of a perfectly matter surface
bigimg: /img/tut2/part1-banner.png
gh-repo: daniel-ilett/cel-shading
gh-badge: [star, fork, follow]
tags: [shaders, unity, lighting, cel-shading, diffuse]
nice-slug: Diffuse Lighting
date: 2019-05-29
---

This tutorial explores one of the simplest lighting models used in 3D rendering - diffuse lighting, also known as Lambertian lighting. In this model, lighting incident on a point on some surface is based solely on the angle between the light source and the normal vector at that point.

<hr/>

# Diffuse Lighting

Diffuse lighting is the basis of most photorealistic lighting models. While more advanced models introduce other types of lighting on top of diffuse lighting, such as specular highlighting and rim/fresnel lighting, we'll need to implement diffuse lighting first of all. As we discussed in Part 0, diffuse lighting is based on the angle between the viewer and the normal vector of a point on a surface. The viewing angle has no bearing on the lighting on the object - that's what specular and fresnel lighting are all about.

Since we're going to be interacting with Unity's lighting system in our shaders, it's going to be impractical to write conventional vertex and fragment shaders. It's possible by using built-in include files and macros, but there are so many moving parts to consider when using the lighting system that your code will end up tediously long and you'll likely make mistakes, especially when interacting with the most advanced lighting features such as global illumination. Instead, we're going to use `surface` shaders, which are Unity-specific types of shaders that handle the boilerplate lighting interactions for us, such as passing lighting data to our shaders. Surface shaders are compiled into vertex and fragment shaders behind the scenes anyway.

## Surface shaders

We'll create a surface shader in a similar way as creating an image effect in the previous Super Mario Odyssey shader series. In the Project pane, right-click and select `Create -> Shader -> Standard Surface Shader`. Or, if you've downloaded the tutorial project from GitHub - the link is at the top of the page - all the template shaders will be created for you.

![Create surface shader](/img/tut2/part1-create-shader.png){: .center-image }

Name this shader `Diffuse`, or if you're using the tutorial project, it's available in `Shaders/Diffuse.shader`. We're greeted by a basic shader - replace the template code with the following:

~~~glsl
Shader "CelShading/Diffuse"
{
    Properties
    {

    }

    SubShader
    {
        Tags { "RenderType"="Opaque" }

        CGPROGRAM
		#pragma surface surf Standard

        struct Input
        {
            float2 uv_MainTex;
        };

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
            o.Albedo = 1.0;
        }

        ENDCG
    }

    FallBack "Diffuse"
}
~~~

Let's go over the parts of the shader in order. It's named `CelShading/Diffuse`, so it'll appear in Unity's shader dropdown under `CelShading -> Diffuse`. The `Properties` block is empty, and we have a `FallBack` defined - the hardware will pick Unity's built-in `Diffuse` shader (different to this one!) if the one we're writing is unsupported. The `SubShader` has the usual `Tags`, but the interesting part starts with `#pragma surface surf Standard`; this is similar to the process we used to define which functions were our vertex and fragment shaders, so we're telling Unity our surface shader is called `surf`, plus there's an added `Standard` parameter that tells Unity we're using the built-in physically-based lighting model. We can use `Lambert` or `BlinnPhong` as alternatives to `Standard` if we don't want physically-based lighting.

The surface shader takes in data encapsulated in an `Input` struct, and outputs data in a `SurfaceOutputStandard` struct (or a `SurfaceOutput` struct when a non-PBR lighting model is used). Inside the shader, we define properties of the surface rather than calculate the lighting ourselves - in this simple example, we're setting the base albedo colour to white.

Also supplied in the tutorial project are materials with each of the shaders attached. Attach the `Materials/Diffuse` material to objects in the example scene, and they'll turn white, with plastic-looking shading. That's diffuse lighting in action!

<hr/>

# Conclusion

<hr/>
