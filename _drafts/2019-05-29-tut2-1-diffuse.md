---
layout: post
title: Cel Shading | Part 1 - Diffuse Lighting
subtitle: Defining the properties of a perfectly matte surface
bigimg: /img/tut2/part1-banner.png
gh-repo: daniel-ilett/cel-shading
gh-badge: [star, fork, follow]
tags: [shaders, unity, lighting, cel-shading, diffuse]
nice-slug: Diffuse Lighting
date: 2019-05-29
---

This tutorial explores one of the simplest lighting models used in 3D rendering - diffuse lighting, also known as Lambertian lighting. In this model, lighting incident on a point on some surface is based solely on the angle between the light source and the normal vector at that point.

<hr/>

# Diffuse Lighting

Diffuse lighting is the basis of most photorealistic lighting models. While more advanced models introduce other types of lighting on top of diffuse lighting, such as specular highlighting and rim/fresnel lighting, we'll need to implement diffuse lighting first of all. As we discussed in Part 0, diffuse lighting is based on the angle between the viewer and the normal vector of a point on a surface. The viewing angle has no bearing on the lighting on the object - that's what specular and fresnel lighting are all about.

We'll look at multiple ways of passing light data to a shader. The more common way of interacting with Unity's lighting system is by using `surface` shaders, which are specific to Unity and handle the boilerplate code involved with lighting interactions for us. Surface shaders will be auto-compiled into several functions for each possible combination of rendering path, which is helpful if we want our shaders to "just work".

If we're willing to do the maths from scratch, we can also use fragment shaders as usual. This is a lot more portable to other platforms, so if you're looking into using these tutorials in an OpenGL/glsl project, then this is the path you'll want to take.

<hr/>

# Surface shaders

We create a surface shader in a similar way as creating an image effect in the previous Super Mario Odyssey shader series. In the Project pane, right-click and select `Create -> Shader -> Standard Surface Shader`. Or, if you've downloaded the tutorial project from GitHub - the link is at the top of the page - all the template shaders will be created for you.

![Create surface shader](/img/tut2/part1-create-shader.png){: .center-image }

Name this shader `DiffuseSurf`, or if you're using the tutorial project, it's available in `Shaders/DiffuseSurf.shader`. We're greeted by a basic shader - replace the template code with the following:

~~~glsl
Shader "CelShading/DiffuseSurf"
{
    Properties
    {

    }

    SubShader
    {
        Tags { "RenderType"="Opaque" }

        CGPROGRAM
        #pragma surface surf Standard

        struct Input
        {
            float2 uv_MainTex;
        };

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
            o.Albedo = 1.0;
        }

        ENDCG
    }

    FallBack "Diffuse"
}
~~~

Let's go over the parts of the shader in order. It's named `CelShading/DiffuseSurf`, so it'll appear in Unity's shader dropdown under `CelShading -> DiffuseSurf`. The `Properties` block is empty, and we have a `FallBack` defined - the hardware will pick Unity's built-in `Diffuse` shader (different to this one!) if the one we're writing is unsupported. The `SubShader` has the usual `Tags`, but the interesting part starts with `#pragma surface surf Standard`; this is similar to the process we used to define which functions were our vertex and fragment shaders, so we're telling Unity our surface shader is called `surf`, plus there's an added `Standard` parameter that tells Unity we're using the built-in physically-based lighting model. We can use `Lambert` or `BlinnPhong` as alternatives to `Standard` if we don't want physically-based lighting.

The surface shader takes in data encapsulated in an `Input` struct, and outputs data in a `SurfaceOutputStandard` struct (or a `SurfaceOutput` struct when a non-PBR lighting model is used - the Physically-Based-Rendering pipeline was introduced in Unity 5). The `Input` struct in this example only has one member variable - `uv_MainTex`. Detailed information on the input structure for surface shaders can be found [here](https://docs.unity3d.com/Manual/SL-SurfaceShaders.html); for the `uv_MainTex` variable, all you need to know is that we can pass texture coordinates to the surface shader by writing `uv` followed by the texture name (in this case, `_MainTex`). Inside the shader, we define properties of the surface rather than calculate the lighting ourselves - in this simple example, we're setting the base albedo colour to white.

Also supplied in the tutorial project are materials with each of the shaders attached. Attach the `Materials/DiffuseSurf` material to objects in the example scene, and they'll turn white, with plastic-looking shading. That's diffuse lighting in action!

## Adding Material Properties

Now let's add some more flexibility to our shader. Right now, everything is defined in the shader and all variables being passed between Unity and the GPU are being passed behind the scenes. We want to be able to modify material parameters in the Inspector.

Let's add some `Properties`. It's common to have some kind of base albedo colour for the material, which we've hard-coded in our shader as full-white. Instead, we'll pass this as a property. Additionally, we'll want to apply a texture to the material, so we'll also pass in `_MainTex` as we have before.

~~~glsl
Properties
{
    _MainTex ("Albedo (RGB)", 2D) = "white" {}
    _Color ("Tint Color", Color) = (1,1,1,1)
}

// Before Input struct definition.
sampler2D _MainTex;
fixed4 _Color;
~~~

Instead of hard-coding the albedo colour, we'll use these properties. If we don't modify them in the material's Inspector, we won't see any changes - but we'll have the flexibility to easily change them. The `surf` function now looks like this:

~~~glsl
void surf (Input IN, inout SurfaceOutputStandard o)
{
    fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
    o.Albedo = c.rgb;
}
~~~

We use the same `tex2D` function as before, using the UV coordinates we passed in the `Input` struct. That struct acts in a very similar way to the `appdata` and `v2f` structs we've seen in past tutorials, although we're only passing one piece of data to the surface shader in this example. The texture sample is multiplied by the base colour property we named `_Color`, and the result of that multiplication is used as the material's output albedo colour.

By moving this logic outside of the shader code, we can create multiple materials with the same behaviour, but different input parameters. You'll see a handful of examples in the tutorial project.

## A few notes on Surface shaders

You may have noticed that the `surf()` function has two variables passed in - the `Input` struct that we defined outselves, and another struct called `SurfaceOutputStandard`. The latter is defined as an `inout` variable, meaning that it's passed into the function as a parameter, but it's also output to the next stage of the graphics pipeline. `SurfaceOutputStandard` is used for much more than just setting the albedo colour; it's used for defining every property about a surface that the standard lighting model utilises.

~~~glsl
// From https://docs.unity3d.com/Manual/SL-SurfaceShaders.html:
struct SurfaceOutputStandard
{
    fixed3 Albedo;      // base (diffuse or specular) color
    fixed3 Normal;      // tangent space normal, if written
    half3 Emission;
    half Metallic;      // 0=non-metal, 1=metal
    half Smoothness;    // 0=rough, 1=smooth
    half Occlusion;     // occlusion (default 1)
    fixed Alpha;        // alpha for transparencies
};
~~~

We'll be exploring some of these in other tutorials. I just thought it was worth noting where the struct comes from - after all, it's passed into the `surf` function seemingly from nowhere!

<hr/>

# Fragment shaders and lighting

<hr/>

# Conclusion

Today we've seen how we can use a surface shader in conjunction with Unity's lighting engine to obtain some simple diffuse shading on our models. In the next tutorial, we'll expand upon this and replace the smooth lighting gradient with a set number of discrete steps to mimic a cartoon aesthetic - this forms the crux of our cel shaded effect.

<hr/>
